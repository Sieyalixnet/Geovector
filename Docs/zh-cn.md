# GeoVector 使用说明

## 产品/项目介绍

### 制作的原因

1. 传统的对于图片的计算需要一定的编程基础或者只能在专业软件中使用。即使使用Python去计算，即使过程并不困难，也必须使用科学计算和图片展示库来实现，不太直观。我希望能减少中间的距离，让更多人通过以简单的方式使用或学习到相关的图片/矩阵计算处理。
2. 这是我学习Rust后的一个实现和巩固过程，加上之前在PaleoCal项目对于Canvas的运用的基础。将Vue的响应性和Rust的高性能融合起来，非常有吸引力。而且后续即使不使用WebAssembly，则可以非常简单地迁移到Rust+前端框架的产品上(如Tauri)。

### 优点

1. 占用容量小、本地可用。就如主页介绍一样，打包后整个项目(不包括图标)只占用了**不到2MB**。由于处理和运算是基于打包好的`WebAssembly`，所以使用本网站**根本不会把处理图片发送出去**，而是使用用户自己的设备进行处理。
2. 功能够用。对于图片单通道(矩阵)，可以快速进行加减乘除。在统计计算方面有映射、标准化。另外最重要的功能就是Padding和Conv2D(二维卷积运算，**可以自定义步长、卷积核大小及卷积核的值**)。尺寸方面有缩小、转置、水平和垂直反转。渲染时可以自由组合你各个颜色的通道，从而进行快速修改。往后还会增加更多算法!
3. 快。基于`Rust`的`WebAssembly`，一张`1920*1080`的图片，渲染到主页面只使用了`~260ms`，如果不使用映射则会减少到`~200ms`。单通道的对另一通道使用矩阵加法使用`~20ms`(但矩阵乘法仍需要花费较长时间)、`3x3`卷积核的卷积运算使用`~150ms`。由于这些运算都在自己的机器上进行、且图片不同，**速度会有差异**(9代以后的处理器估计都远比这里所说的快)。
4. 兼容性强。在页面布局时充分考虑到手机操作，只在少量地方进行了平台的特殊适配，因此，在手机上看到的布局会和电脑上非常相似，但又能完全使用各种功能。
5. 后续扩展性强。因为每个通道都是封装好的数据的类型，涉及到图片处理本身的链式调用异常方便。后续会增加自定义的脚本语言进行调用。因为链式处理的优势，则可以在不解析文本为AST的情况下，也可以轻松使用脚本语言进行链式调用。因为现在都是基础操作，操作仍不太方便，**后续维护时会把常用的功能的组合放到功能上，也会增加功能让大家自定义脚本语言**。

## 使用

### 浏览你的图片

进入主页面之后，请您点击`Browse Your Image!`浏览您的图片，暂时只支持PNG和JPEG(推荐PNG)进行上传。您也可以从别的软件中导出JSON，进而在本产品中加载JSON，但是JSON文件必须满足一定的构造才会被加载转移(请参考 `JSON文件结构` 一章)。

一旦加载完后，首页的介绍页面即会切换(因为这会直接把图片写如到`WebAssembly`的线性内存当中，加载需要一定时间)。您可以看到三个部分:

- 装载着主画布(Main Canvas)的主画布区域(中间白色大框)
- 文件操作(File Operation)
- 文件列表(Files): (即File Name...所在的`文件框(或文件 File)`，每个图片/JSON文件将会使用一个文件框，文件列表会装载所有文件)。

您可以分多次加载数张图片/文件。
由于在进行操作时基本顺序是`读取文件->计算->渲染`，因此在本文中，介绍的顺序也是从最核心的`文件列表、文件和图层`开始，再到`文件操作`，最后到`主画布`。您可以根据自己所在步骤来查阅本文档。

**!!注意: 加载过大的图片会造成比较长时间的等待，本产品也不适合处理过大的图片。建议尺寸在`2000px*2000px`以下，视设备和浏览器而定。**

### 文件框(File)

#### 基本布局和操作

- 文件框内最上部分即文件名(可以修改)，点击文件名(File Name)所在行的其余地方，会隐藏/显示文件框内的所有图层。**!!注意: 请保持文件名唯一性，否则加载图片时可能会错误加载。**

- 中间为文件内所有`图层(Layer)`。具体图层的内容请在下方观看。

- 图层下方为便利操作，`自动映射(Auto Reflect)`和`自动更新缩略图(Auto Update Thumbnails)`，其对本文件内所有图层生效:
  - 自动映射: 图层内的缩略图生成时，以及把图层加载主画布时，会把图片自动映射成`0-255`范围内。`0-255`范围是图片渲染时，每个像素点显示的范围。渲染黑白图片时，越大就会变为白色，越小就会变为黑色。渲染彩色图片时，会把红、绿、蓝、透明颜色通道进行合成，某个颜色通道的该像素点在`0-255`范围中越大，则该像素点该颜色越重。如果您不清楚图片的像素点相关基础，请参考一些基础的图片渲染(像素点颜色)的基础知识。**!!注意: 自动映射 只会在渲染时对渲染出来的图像产生影响，不会对图层数据本身产生影响，请放心使用该功能。**
  - 自动更新缩略图: 每次进行`图层操作(Layer Operation)`时会自动重新渲染缩略图(缩略图相关内容请看  图层 - 缩略图  的内容)。
  - 若您取消勾选`自动更新缩略图`，则会见到其右侧出现`更新缩略图(Update Thumbnails)`按钮，您可以点击来手动更新缩略图。

#### 文件框内内容与说明

每一个文件可以装载多个图层。
传统的照片是由红(R)、绿(G)、蓝(B)、透明(Alpha)四个通道组成，所以加载普通的图片下就会加载这四个图层。
JSON文件则可以放入多个图层，因此加载时会根据JSON文件里面的内容而定。

### 图层

#### 基本布局

每个图层会有三个部分，从左往右，最左侧为缩略图，次之是图层名、图层操作和图层信息，最后是根据操作而加载的具体操作框。默认选中的操作为图层操作。

#### 缩略图

顾名思义，缩略图就是本图层的缩略显示。

- 加载到主画布: 点击缩略图就可以在主画布中加载本图层。

关于更新缩略图的问题。缩略图生成需要耗费一定性能。但为了操作便利性，会默认打开自动映射和自动更新缩略图，更新缩略图也可以手动完成。请参考 文件框 - 基本布局和操作 。

#### 图层名、图层操作(Layer Operation)和图层信息

在本列中，从上至下分别是图层名、图层操作(Layer Operation)和图层信息。

##### 图层名

- 图层名就是该图层的名称，可以自由修改，但不能与其他图层名相同(包括其他文件内的图层)，其名字与渲染有关。 **!!注意: 请务必保持图层名唯一性。否则加载缩略图时可能会错误加载，另外在进行图层操作和文件操作时也可能会出现错误**。
- 图层名左侧的`-`可以让该图层进行省略展示，点击`+`号即可恢复该图层。
- 若图层名以`R`开头，图层底部会变为浅红色，这是为了提高辨识度。同样的以`G`、`B`、`A`开头都会有相应的颜色。这只是为了提高辨识度的装饰，不会对操作产生任何影响。

##### 图层操作(Layer Operation)

这是本产品的核心功能区。这里可以选择要进行的图层操作，分别有:`内部的图层操作(Layer Operation)`、`计算(矩阵)(Calculate(Matrix))`、`计算(数值)(Calculate(Value))`、`变形(Transform)`、`填充(Padding)`、`二维卷积运算(Conv2d)`
注意，图层操作会对本图层数据进行直接**覆盖运算，且不可回退**，您可以对将要处理的图层进行 内部的图层操作 - 复制 之后再进行操作。

- 内部的图层操作: 可以对图层进行一些操作
  - 上下移动(Upward、Downward)。让图层在文件内向上或向下移动。
  - 复制(Copy)。复制一个一样的图层到本文件，它实施上会创建一个新、一样的图层。
  - 删除(Delete)。在文件内删除这个图层。不可恢复。
  - 转移至(Move To)。把一个图层从一个文件移动到另一个指定的文件内。类似于剪切。
  - 下载图像(Download Image)。下载该图层的图像。因为单一图层肯定是不透明的灰度图。
  - 下载JSON数据文件(Download JSON)。下载该图像的JSON数据。下次载入时会恢复。若载入的JSON内的文件名相同，则这些图层会合并到已有文件名中，否则就会新建。由于载入时会检测图层名是否重复，若重复则图层名在载入会对图层名进行自动修改。
- 计算(矩阵): 图层与另一个图层进行运算，请先选择一个计算方法，再选择另一个图层。提供以下算法:
  - 两个图层间按元素加(Add)、减(Sub)、乘(Mul)、除(Div)运算(请确保长宽相等)，
  - 矩阵乘法(MM)。另外在满足条件情况下可以使用矩阵乘法(请确保两个图层的是否可乘，矩阵乘法会消耗大量性能，等待时间较长，请谨慎使用)。
- 计算(数值): 图层会根据数值/选择，对本图层进行运算。提供以下算法:
  - 图层与数值间按元素加(Add)、减(Sub)、乘(Mul)、除(Div)运算。(比如Add 1，则矩阵内全部元素的数值会+1)。
  - 标准化(Normalize)。可以选择`min_max`和`z_score`，`min_max`的计算方法为`(value-min)/(max-min)`。`z_score`为`(x-μ)/σ`，具体请查阅统计学相关资料。
  - 替换(Replace)。把图层内指定数据范围的数据替换成指定值。
  - 绝对值化(Abs)。把图层内所有数据取其绝对值。
  - 映射至(Reflect to)。把**整张图层数据范围**映射到目标范围，假设指定目标范围为t_min和t_max。它会先使用`min_max`来映射到`0-1`范围再执行即`(0-1)*(t_max-t_min)+t_min`，映射到指定范围。
  - 范围映射至(Range Reflect to)。把图层内**指定数据范围**映射到目标范围。与`映射至`的差异在于该功能可以指定需要映射的数据范围。假设指定指定数据范围为min_range和max_range、目标范围为t_min和t_max。它会先使用`min_max`对在`min_range-max_range`的范围内的数据映射到`0-1`范围再执行即`(0-1)*(t_max-t_min)+t_min`，映射到指定范围。
- 变形: 这项主要用于图形的形状变化。
  - 转置(Transpose)。执行矩阵的转置。
  - 水平翻转(Reverse Hori.)、垂直翻转(Reverse Vert.)。对0维、1维进行反转。理论上，使用转置、水平翻转和垂直翻转即可以完成所有顺时针和逆时针变换，请自由组合。
  - 重新缩放至(Rescale to)。把图片按照一定比例**等比例缩小**(不能放大)至指定数值之内，您应该在数值中指定的是最长边需要缩放至的长度。根据这个长度会计算出长宽缩小比例(等比例)。注意，如果缩放至的指定值不能被长边整除，那会把最长边缩小到该比例以下。例: 假设一张`1920*1080`的图片，填入192，则会长宽各缩小为原来的1/10，为`192*108`；假设填入200，由于1920不能被200整除(此时计算比例为1/9.6，但比例的分母不能为小数，所以比例的分母会向上取整至10，即1/10)，它还是会缩放至1/10，变为`192*108`。
- 填充(Padding)。这是二维卷积运算的前置算法之一，以解决在二维卷积运算之后图片尺寸缩小的问题。其会在左右、上下各边依次增加等同边长的填充值，您可以根据需要指定填充的值(Padding Value)，还可以指定填充的次数(Padding Times)。
- 二维卷积运算(Conv2d)。卷积运算的定义需要自行查阅。这里二维计算的模式是最通用的模式，即卷积核必须完全覆盖在原数据上才会进行一次卷积运算。您可以自定义指定卷积核的大小(Kernel Size)、步长(Stride)和卷积核的值(Kernel)。

这些运算可以综合起来，达到某种目的
假设我想提取一个图片的红色通道的边缘，以突出其原来的边缘，应该怎么做呢？

1. 对红色通道使用 图层操作(Layer Operation)->复制(Copy) 。以获得该通道的副本
2. 对该副本使用 填充(Padding)，指定填充值为0，次数为1。
3. 对该副本使用 二维卷积运算(Conv2d)，指定卷积核大小为3、步长为1，卷积核以下填写
  `-1 0 1`
  `-1 0 1`
  `-1 0 1`
  根据这步操作，已经在保持原大小下，将图层的边缘提取出来了。可以发现，在边缘处，数值会异常高或异常低，而在非边缘处，它会接近±常量，这个常量需要依图片而定，在我自己使用的某张测试图片中，认为约为±5以内就是非边缘区域；<-5或>5的区域为边缘区域。
4. 对该副本使用 计算(数值)->替换(Replace)。根据上述自己情况填入，根据我的状况，把-5,5范围内的数据替换成5。(即填入-5 5 5)
5. 对该副本使用 计算(数值)->绝对值化(Abs)。第4-5步操作，把整个图片的范围都映射到了大于5的范围，并且把非边缘地区变为了最小值5。
6. 对该副本使用 计算(数值)->映射至(Reflect to)。最小值为0，最大值为1。这是非边缘区域会为0，边缘但不明显的区域会接近0，边缘且明显的区域会接近1。
7. 对该副本使用 计算(矩阵)->按元素乘(Mul)。 指定为原先的R通道图层。由于越为边缘的区域越接近1，乘以R通道的图层就越接近原值；越为非边缘的区域越接近0，乘以R通道的图层就越接近0。所以这样就提取出了R通道的边缘了

后续您还可以再进行映射至`0-255`。
这样，新的副本就是提取了边缘的红色通道了。

##### 图层信息

会显示图层的最小值(min)、最大值(max)、宽度(W)、高度(H)信息。该信息会自动更新。

### 文件操作(File Operation)

文件操作主要用于文件间、文件间图层的操作。
文件操作默认是省略的，需要点击`File Operation`所在行以显示。

- 合成为RGBA图像(Merge to RGBA image)。指定4个图层作为渲染红(R)、绿(G)、蓝(B)和透明度通道(Alpha)。可以不指定透明度通道，如果不指定，则会临时生成一个值为`255`(即完全不透明)的同等长宽的图层作为透明度通道。
  - **!!注意: 这些图层之间，长宽应当一致，否则会出错。**
  - **!!注意: 合成图层时 不会 映射到0-255，您需要对各通道进行映射到合理的范围才能正确进行渲染。如果您发现您合成后某种颜色偏低，请查看是否在经过处理之后导致该图层的值总体偏低。颜色合成问题需要您查阅相关资料，大致基础知识可以在上文中的 文件框 - 基本布局与操作 中查阅。**
- 下载主画布图像(Download Main Image)。下载现在在主画布中的图像。现在只提供最高质量的PNG格式的图片。
- 下载JSON数据(Download JSON Data)。指定一个文件，会把其内容全部转为JSON并下载到您设备中。下次使用时，可以直接浏览并载入这个JSON文件即可恢复该文件。若载入的JSON内的文件名相同，则这些图层会合并到已有文件名中，否则就会新建。由于载入时会检测图层名是否重复，若重复则图层名在载入会对图层名进行自动修改。
- 新建一个空的文件(Create a New Empty File)。新建一个文件。后续您可以通过 图层操作 - 移动(Move To) 等操作，在文件中获取一些新的图层。
- 新建一个图层(Create a New Layer)。在指定文件中新建一个新的图层。您可以指定其宽(Cols(Width))、高(Rows(Height))和填充值(Value)。
- 删除文件(Remove File)。选择一个文件进行删除。

### 主画布区域

主画布区域由主画布框、主画布及缩放键构成。

- 主画布框: 它是装着主画布的可以上下左右滚动的框。它与主画布内的图像之间存在的空白边缘的并不是图像本身(并不会影响图像)，而是缩放留下的空间。
- 主画布(Main Canvas): 图像渲染的位置。在点击缩略图或通过合成RGBA图像操作均可以使得图层渲染到主画布内。
  - 鼠标在主画布在移动时，可以在主画布框右下侧看到鼠标所在点的X、Y坐标信息，还能看到对应该坐标的值，这与渲染的内容有关:
    - 如果渲染的是单图层，那还会看到该坐标对应的灰度值Value；
    - 如果是通过合成RGBA图像进行渲染的，则会看到各个通道的值(分别是R、G、B、A)；
    - 如果在通过合成RGBA图像进行渲染时没有指定透明通道，则只会有R、G、B三个通道。
  - 鼠标在主画布上点击时，如果渲染的是单图层，则可以在主画布框左下侧看到一个输入框及√、X按钮。通过这个可以修改值。在点击之后，在输入框中输入对应的值，点击√即可修改对应坐标的值。而点击X则会关闭这个输入框。在修改值之后，您需要手动重新渲染该图层到主画布上。**!!注意: 这种操作像素点的修改方式非常原始，只建议使用这个功能进行非常有限的小幅度修改**
- 缩放。缩放有三个键(第四个键为预留区域，暂时不可用)。`+`为放大，`-`为缩小。在放大、缩小之后，第三个按键`Zoom`会显示现在放大、缩小的倍率是多少(以1为基准，每次放大、缩小都会调整0.1)。点击第三个按键`Zoom`会把缩放倍率恢复到1。**!!注意: 该缩放功能仅是调整观察主画布时的缩放倍率，对主画布的图像、数据完全不会有影响。**

## 补充说明

### JSON文件结构

```JAVASCRIPT
{
    files: [{
        filename: filename1,
        layers: [
            {
                name: layername,
                cols: cols,
                rows: rows,
                data: data
            }
        ]
    },
    {
        filename: filename2,
        layers: [
            {
                name: layername1,
                cols: cols,
                rows: rows,
                data: data
            },
            {
                name: layername2,
                cols: cols,
                rows: rows,
                data: data
            }
        ]
    }
    ]
}

```

简单来说，files是数组，其可以存多个file对象。
file对象由filename和layers构成，filename就是文件名，layers是一个数组，可以存多个layer对象。
layer对象由name, cols, rows, data组成。name就是图层名，cols是列数(宽)、rows是行数(高)，data是存放数据的数组。**!!注意: data数组的长度应当等于cols*rows，但即使不等，载入时也不会报错，但渲染时会出错。**

您完全可以通过其他语言进行生成:

```Python
import json
import random

def random10000():
    return [random.random()*x for x in range(0,10000)]
  
result = {
    "files":[
        {
            "filename":"fileFromPython",
            "layers":[
                {"name": "R_1238u8ydu8",
                "cols": 100,
                "rows":100,
                "data":random10000()},
                {"name": "G_1238u8ydu8",
                "cols": 400,
                "rows":25,
                "data":random10000()}
            ]
        }
    ]
}

if __name__ == '__main))':
    jsonWrite = json.dumps(result)    
    with open('geovec.json', 'w') as f:
        f.write(jsonWrite)

```

这个示例中，`random10000`就是一个返回10000个数字的数组。在使用Torch或NDArray时，可以直接调用tensor的转换为数组的函数，并用`shape`来获取数组的rows和cols。

